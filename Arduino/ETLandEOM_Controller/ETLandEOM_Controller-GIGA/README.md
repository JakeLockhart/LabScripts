# ETL and EOM Controller
This project uses an Arduino Giga R1 Wifi board.
The Giga is used to send two outputs, one TTL pulse being sent to the ETL and one analog pulse being sent to an amplifyier and then the EOM.

## Hardware
The Giga has a voltage range of 0-3.3V and many more available pins (GPIO, Digital (PWM), Analog In, DAC0/1). The board has two microprocessors, the M7 core has a clock speed of 480MHz and the M4 core has a clock speed of 240MHz. For most applications, only the M7 core needs to be programmed. The voltage range for the DAC ports is 0-2V with a resolution of 0.8MV. This board can access wifi through an antenna... In otherwords, this board is extremely overquallified for the task of recieving and outputting signals to control the ETL and EOM. However, the DAC output range is appropriate for this project.

## Logic
- **Reference Tables**
  - Two references tables are included in this project, OscilloscopeVoltage.cpp and PowerResults.cpp. The OscilloscopeVoltage.cpp file contains the low signals and high signals that are created by MScan based on the input laser intensity percentage [%]. The PowerResults.cpp contains the output laser intensity [mW] with respect to the input laser intensity percentage [%]. These two files are used together with a linear interpolation (multiple files) to determine the signals needed to create a a specific laser intensity output for the microscope.
- **Input Parameters**
  - This section was designed so that the user only needs to edit this file to control the desired imaging plane depths and laser intensity power. It is separated into two sections: User Inputs and Do Not Edit. The 'User Inputs' section controls the user defined parameters and can be readily updated. The 'Do Not Edit' section includes board parameters that are necessary for the board to function and should not need to be modified. Specifically, items like PulseWidth and PulseGap have been tuned to ensure that created pulses do not occur during low signals output by MScan. It is unlikely that this section needs to be edited.
- **Input Signal Detection**
  - Input signals are currently generated by an Arduino Due to simulate signals created by MScan. Each pulse is detected based on the attachInterrupt() function. Signal detection is relatively straightforward.
- **Output Signal Creation**
  - The attachInterrupt() function is used to detect the rising edge of incoming pulses created by MScan. When a pulse is detected, the ISR function (FlagState.cpp) is called. This ISR simply turns a boolian Flag from false to true. Within the void loop() {}, the Flag is constantly monitored. Whenever the Flag is true, the CreatePulses.cpp function is called to output a digital and analog pulse based on the Reference Tables and Input Parameters.
 - The CreatePulses.cpp has two functions. First the analog pulse controls the EOM. Every pulse from MScan requires a single analog pulse from the Arduino so that each imaging plane is given power. The amplitude of each analog pulse is dependent on the image plane cycle. Second the digital pulse controls the ETL. 
## Notes
- The generation of pulses is dependent on quickly detecting incoming signals and creating output signals. By using void loop() {} with a flag method for the ISR, it is possible to miss incoming signals and cause several timing issues. This means that the output pulse must be shorter than the incoming pulse. This is fine so long as the output pulse is centered in the incoming pulse. This means that the top and bottom edges of the imaging planes will not be given power, but this is acceptable so long as penetrating arterioles are still in focus.
  - This is no longer a concern. Using the attachInterrupt() to call a boolian flag which then dictates pulse creation does not appear to be slow or miss input signals. In fact The current version of this code uses two flags, one dependent on a frame trigger, the next dependent on a line trigger and no issues have been found on benchtop. A single flag was used on the R2P rig, and no issues were found there either.
- What are the incoming signals from MScan?
  - The output from MScan (AO0) are single pulses that appear to have a pulse width of 40us and a gap between pulses of 8us. I was originally told that each of these pulses were the duration of an entire frame... This is not possible given the pulse width does not change when the field of view is altered (increasing the frame rate and supposedly decreasing the pulse width of these pulses). Instead these pulses remain a constant pulse width regardless the field of view. I have found that these signals are actually the duration of a single line as the mirror rastors across the field of view. The high signal occurs as the rastor moves across a line and the low signal occurs during the turnaround to the next line (See manual). This has been validated by recording two separate signals with two distinct field of views (512x512 pixels & 128x512 pixels).
  - It is important to note that a frame trigger and line trigger are two distinct signals created by the computer in order to coordinate peripheral components with the R2P. The frame trigger appears to have a pulse width of 300us regardless the field of view. However, the manual states that the frame trigger only occurs in the top left pixel, though this pulse is longer that the line trigger pulse (~5x larger). This is slightly confusing but the frame trigger works well for the previous ETL configuration.

## Future goals
- ~~NEED TO CHECK THIS!!!!
CURRENTLY A VOLTAGE STEP ONLY OCCURS WHENEVER AN ETL PULSE IS SENT. SHOULD EACH VOLTAGE STEP BE CONTAINED BETWEEN THE ETL PULSES? HOW DOES GARDASOFT CHANGE THE IMAGING PLANE?? IS IT ONE IMAGING PLANE CHANGE PER ETL PULSE OR IS IT (for 10 imaging planes) 10 IMAGE PLANE CHANGES PER ETL PULSE?~~
- The current version of this board is wired to a breadboard. Previous iterations of this design have shown that this is extremely noisy. I need to solder these connections together on a protoboard.
- Prior to soldering I need to validate the line trigger TTL pulse output from the MScan software. This exists but I have not found any technicians or lab members that have expertise working with it. If not, I need to return to the comparator in order to make Arduino-detectable signals and find a solution to reduce the Gibbs phenomenon that is occuring to the AO0 signal.